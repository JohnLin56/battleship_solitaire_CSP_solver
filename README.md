# battleship_solitaire_CSP_solver
## Heuristic Description

The variables in my CSP solver are the positions on the board, e.g. (1, 1) or (3, 4). Each variable has its own domain, which initially are all the same (if we exclude any given hints). In other words, when the input file is imported and configured to fit my solver, there will be N^2 variables, where N is the number of rows or columns; each variable has a domain = {“S”, “W”, “L”, “R”, “T”, “B”, “M”}. These letters represent the same meaning as described in A3 handout.

After configuring the board, I first filtered it with all the constraints I created, making sure that it is arc consistent. Then, I decided to search for the positions of all the battleships first. Since the battleships take up a lot of space in the board, branching on them first can give me more information and thus more variables can be pruned from the domain of each variable later on (e.g. guessing the position of a battleship first allows me to assume that big pond of water around it). The alternatives of fitting a battleship on the board are also much less than the different options of fitting a smaller ship on the board, as the battleships’ space is less flexible with the row and column constraints. Following the logic of searching for big ships first, the next type of ship I branched on was the cruiser, then the destroyer, and finally the submarine.

I also tried to use MRV to choose the combination of ship positions that I wanted to branch on first. The process of my implementation was to first find all the possible combinations of the head position of the battleship, then for each combination of the battleship positions, expand on it and find all possible combinations of the head position of the cruisers, and so on. My idea was to track the domain size of each possible head position of the ship, then expand on the one with the smallest domain to find the next type of ship. The reason behind this is because the variable with smaller domain means that it is more restricted. If looping over them cannot yield to a solution, it results in a DWO, which allows us to move on to the next alternative earlier. However, somehow I kept getting errors with the implementation and had to give up on this.
